global !p
import glob, time, subprocess

def get_fig_num(filename):
      regx = re.search("fig(\d+)", filename)
      return int(regx.group(1))

def get_latest_fig_num(directory):
    files = glob.glob(f"{directory}*.png")
    result = 0
    if files:
      latest = max(files, key=get_fig_num)
      result = get_fig_num(latest)

    return result

def get_new_fig_path(snip):
  directory = f"./{snip.basename}_figs/"
  os.makedirs(directory, exist_ok=True)
  num = get_latest_fig_num(directory) + 1
  return f"{directory}fig{num}.png"

def get_path_from_snip(snip):
  snippet_text = snip.buffer[snip.snippet_start[0]] # Get snippet line from buffer
  return re.match(r"!\[\]\((.*)\)", snippet_text).group(1) # get path inside ()

def handle_xournalpp(snip):
  png_path = get_path_from_snip(snip)
  xopp_path = png_path.replace("png", "xopp")
  commands = " && ".join([
    f'xournalpp "{xopp_path}"',
    f'xournalpp --export-no-background -i "{png_path}" "{xopp_path}"',
    f'convert -trim "{png_path}" "{png_path}"'
    ])
  subprocess.Popen(commands, shell=True)

def build_table(text):
  rows = text.split("\n")
  col_num = rows[0].count('|') - 1
  format_row = lambda row: row.strip('|').replace('|', ' & ') + "\\\\" if '--' not in row else '\\hline'
  content = "\n".join([format_row(row) for row in rows if row])
  beggining = "\\begin{tabular}{ |"  + "c|"*col_num + " }"
  ending = "\\end{tabular}"
  return f"{beggining}\n{content}\n{ending}"
endglobal
###########################
# Sections and Paragraphs #
###########################
snippet sec "Section" b
# ${1:Section Name}
$0
endsnippet

snippet ssec "Sub Section" b
## ${1:Section Name}
$0
endsnippet

snippet sssec "SubSub Section" b
### ${1:Section Name}
$0
endsnippet

snippet par "Paragraph" b
#### ${1:Paragraph Name}
$0
endsnippet

snippet spar "Paragraph" b
##### ${1:Paragraph Name}
$0
endsnippet

###################
# Text formatting #
###################

#snippet * "italics"
#*${1:${VISUAL}}*$0
#endsnippet
#
#snippet ** "bold"
#**${1:${VISUAL}}**$0
#endsnippet
#
#snippet *** "bold italics"
#***${1:${VISUAL}}***$0
#endsnippet

snippet /* "Comment"
<!-- ${1:${VISUAL}} -->$0
endsnippet

################
# Common stuff #
################
snippet link "Link to something"
[${1:${VISUAL:Text}}](${3:https://${2:www.url.com}})$0
endsnippet

snippet img "Image"
![${1:pic alt}](${2:path}${3/.+/ "/}${3:opt title}${3/.+/"/})$0
endsnippet

snippet ilc "Inline Code" i
\`$1\`$0
endsnippet

snippet cbl "Codeblock" b
\`\`\`
$1
\`\`\`
$0
endsnippet

snippet refl "Reference Link"
[${1:${VISUAL:Text}}][${2:id}]$0

[$2]:${4:https://${3:www.url.com}} "${5:$4}"
endsnippet

snippet fnt "Footnote"
[^${1:${VISUAL:Footnote}}]$0

[^$1]:${2:Text}
endsnippet

snippet detail "Disclosure"
<details${3: open=""}>
  ${1:<summary>${2}</summary>}$0
</details>
endsnippet


###########################
##### LaTeX snippets #####
###########################
#
snippet mk "Math" wA
$$${1}$$`!p
if t[2] and t[2][0] not in [',', '.', '?', '-', ' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`$2
endsnippet

snippet ms "Math" wA
$${1}$`!p
if t[2] and t[2][0] not in [',', '.', '?', '-', ' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`$2
endsnippet

snippet lim "limit" w
\lim_{${1:n} \to ${2:\infty}} 
endsnippet

snippet sqrt "\sqrt{}"
\sqrt{${1:${VISUAL}}} $0
endsnippet

snippet set "set" w
\\{$1\\} $0
endsnippet

snippet beg "begin{} / end{}" bA
\\begin{$1}
${2:${VISUAL}}
\\end{$1}
endsnippet

priority 100
snippet .. "ldots" i
\ldots
endsnippet

snippet frac "Fraction" i
\\frac{${1:${VISUAL}}}{$2}$0
endsnippet

priority 100
snippet "([^ {]+)/" "symbol frac" wr
\\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet

snippet '([A-Za-z])(\d)' "auto subscript" wr
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`
endsnippet

snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet

snippet sympy "sympy block" w
sympy $1 sympy$0
endsnippet

priority 10000
snippet 'sympy(.*)sympy' "sympy" wr
`!p
from sympy import *
x, y, z, t = symbols('x y z t')
k, m, n = symbols('k m n', integer=True)
f, g, h = symbols('f g h', cls=Function)
init_printing()
snip.rv = eval('latex(' + match.group(1).replace('\\', '').replace('^', '**').replace('{', '(').replace('}', ')') + ')')
`
endsnippet

snippet pmat "pmat" wA
\begin{pmatrix} $1 \end{pmatrix} $0
endsnippet

snippet bmat "bmat" wA
\begin{bmatrix} $1 \end{bmatrix} $0
endsnippet

snippet () "left( right)" wA
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr "left( right)" i
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr( "left( right)" i
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr| "left| right|" i
\left| ${1:${VISUAL}} \right| $0
endsnippet

snippet lr{ "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

snippet lrb "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

snippet lr[ "left[ right]" i
\left[ ${1:${VISUAL}} \right] $0
endsnippet

snippet lra "leftangle rightangle" wA
\left<${1:${VISUAL}} \right>$0
endsnippet

snippet sum "sum" w
\sum_{${1:n=1}}^{${2:\infty}} ${3:a_n}
endsnippet

snippet prod "product" w
\prod_{${1:n=${2:1}}}^{${3:\infty}} ${4:${VISUAL}} $0
endsnippet

snippet part "d/dx" w
\frac{\partial ${1:V}}{\partial ${2:x}} $0
endsnippet

snippet td "to the ... power" i
^{$1}$0
endsnippet

snippet __ "subscript" iA
_{$1}$0
endsnippet

snippet ooo "\infty" wA
\infty
endsnippet

snippet <= "leq" iA
\le 
endsnippet

snippet >= "geq" iA
\ge 
endsnippet

snippet lll "l" iA
\ell
endsnippet

snippet xx "cross" wA
\times 
endsnippet

priority 100
snippet '(?<!\\)(sin|cos|arccot|cot|csc|ln|log|exp|star|perp)' "ln" rw
\\`!p snip.rv = match.group(1)`
endsnippet

priority 200
snippet '(?<!\\)(arcsin|arccos|arctan|arccot|arccsc|arcsec|zeta|int)' "ln" rw
\\`!p snip.rv = match.group(1)`
endsnippet

priority 100
snippet "([^ {]+)bar" "bar" rw
\bar{`!p snip.rv=match.group(1)`}
endsnippet

snippet inn "in " w
\in 
endsnippet

snippet cc "subset" wA
\subset 
endsnippet

priority 90
snippet -> "to" w
\to 
endsnippet

snippet norm "norm" w
\|$1\|$0
endsnippet

###########################
##### Custom snippets #####
###########################

snippet eqq "equivalent" wA
\equiv 
endsnippet

snippet "(\w+)!(\d+)" "index" wrA
`!p snip.rv=match.group(1)`~!~`!p snip.rv=match.group(2)`
endsnippet

snippet /= "not equal" wA
\neq
endsnippet

snippet range "range" wA
${2:0} \leq $1 < ${3:\#xs} $4
endsnippet

snippet # "cardinal" w
\#
endsnippet

snippet brang "bracket angled" wA
\langle $1 \rangle
endsnippet

snippet AA "forall" wA
\forall
endsnippet

snippet EE "exists" wA
\exists
endsnippet

priority 100
snippet --> "arrow" wA
\rightarrow 
endsnippet

snippet andd "and" wA
\wedge 
endsnippet

snippet orr "or" wA
\vee 
endsnippet

snippet props "props" iA
\equiv \\{ \text{$1} \\}
$0
endsnippet

snippet negg "negation" wA
\neg 
endsnippet

snippet undd "underline" wA
\underline{${1:${VISUAL}}}
endsnippet

snippet mbf "bold math" wA
\mathbf{${1:${VISUAL}}}
endsnippet

snippet bf "bold text" wA
\textbf{${1:${VISUAL}}}
endsnippet

snippet squigg "squiggly arrow" wA
\rightsquigarrow 
endsnippet

snippet o+ "oplus" wA
\oplus
endsnippet

snippet pegg "pegado" wA
\triangleright
endsnippet

snippet Sig "Uppercase Sigma" wA
\Sigma
endsnippet

snippet PI "Uppercase Pi" wA
\Pi
endsnippet

priority 50
snippet RR "real" w
\mathbb{R}
endsnippet

snippet NN "natural" wA
\mathbb{N}
endsnippet

snippet II "I" wA
\mathbb{I}
endsnippet

snippet KK "K" wA
\mathbb{K}
endsnippet

snippet uiN "undefined integral" wA
\int $1~dx $0
endsnippet

snippet diN "integral" wA
\int_{${1:-\infty}}^{${2:\infty}}$3~${4:dx} $0
endsnippet

snippet uP "up arrow" wA
\uparrow
endsnippet

snippet ++ "concatenation operator" wA
\concat 
endsnippet

snippet concatDef "concat command definition" b
\newcommand{\concat}{%
  \mathbin{{+}\mspace{-8mu}{+}}%
}
endsnippet

snippet => "Right arrow" iA
\Rightarrow 
endsnippet

snippet taylor "taylor" wA
\frac{f^{(${1:n})}(${2:a})}{${3:n}!} $0
endsnippet

snippet funcder "Function Derivation" wA
${1:f}^{(${2:n})}(${3:a}) $0 
endsnippet
#snippet vD "Variable declaration" iA
#$Var~ $1: ${2:Int};$\
#$0
#endsnippet

snippet stn "state name" wA
$\sigma_{$1}$
endsnippet

snippet lnn "line name" wA
$\ell_{$1}$
endsnippet

priority 100
snippet "(\w+)mt" "maps to" rw
`!p snip.rv=match.group(1)` \mapsto $1
endsnippet

snippet conm "conjunto matriz" wA
${1:\mathbb{K}}^{${2:n}\times ${3:n}} $0
endsnippet

snippet iff "Leftrightarrow" wA
\Leftrightarrow 
endsnippet

snippet rH "Row header" bA
|    linea   | nombre del estado |       estado/guardas      |   aclaracion   |
|:----------:|:-----------------:|:-------------------------:|:--------------:|
|     -      |    $\sigma_{0}$   | $$1$                      | Estado inicial |
endsnippet

snippet terh "Inline Terna de Hoare" wA
\\{${1:P}\\}~${3:S}~\\{${2:Q}\\} $0
endsnippet

snippet terH "Terna de Hoare" wA
\\{${1:P}\\}
$3
\\{${2:Q}\\}
$0
endsnippet

snippet "gen(\w+)" "Generalization" wr
${1:`!p snip.rv=match.group(1)`}_${2:1},\ldots,$1_${3:n}
endsnippet

snippet mc "mathcal" w
\mathcal{$1} $0
endsnippet

snippet "dom([a-zA-Z])" "Dominio" rwA
Dom(`!p snip.rv=match.group(1)`) $0
endsnippet

priority 100
snippet "(\w)RR" "R^n" rw
\mathbb{R}^`!p snip.rv=match.group(1)` $0
endsnippet

snippet fndef "function definition" wA
${1:f}:${2:\mathbb{R}^n}\to ${3:\mathbb{R}}
endsnippet

snippet "txt([a-zA-Z]+)" "text" r
\text{ `!p snip.rv=match.group(1)`$2 } $1
endsnippet

priority 50
snippet "([^ {]+)sqrt" "square root" rwA
\sqrt{`!p snip.rv=match.group(1)`} $0
endsnippet

snippet c= "subset" Ai
\subseteq 
endsnippet

snippet "([^ ]+)<-([^ ])" "left arrow" rA
`!p snip.rv=match.group(1)` \leftarrow `!p snip.rv=match.group(2)`
endsnippet

snippet wp "weakest precondition" w
wp.($1).($2)
endsnippet

snippet wpif "wp(if...fi)" bA
(${1:B1} \vee ${2:B2})
\wedge ($1 \Rightarrow wp.(${4:S0}).${3:${VISUAL}})
\wedge ($2 \Rightarrow wp.(${5:S1}).$3)
endsnippet

#snippet if "if..fi" w
#if~${1:expression}\rightarrow $2
#$3
#fi
#endsnippet

snippet else "[] ->" w
[]~${1:expression}\rightarrow $2
$3
endsnippet

snippet grad "gradient" w
\nabla ${3:f}(${1:\bar{a}})$2
endsnippet

snippet fndom "function definition based on Dom(f)" wA
${1:f}:${2:Dom(f) \subseteq \mathbb{R}^n}\to ${3:\mathbb{R}}
endsnippet

snippet bola "bola" w
B(${1:\bar{a}}, ${2:r})
endsnippet

snippet dim "Dimension" wA
dim~
endsnippet

snippet verdo "verification do" wA
P \Rightarrow ${4:I} 
\wedge $4 \wedge \neg (${1:B}) \Rightarrow ${3:Q}
\wedge \\{$4 \wedge $1\\} ${2:S} \\{$4\\} 
\wedge $4 \wedge $1 \Rightarrow t \ge 0
\wedge \\{$4 \wedge $1 \wedge t = T\\} $2 \\{t < T\\} 
endsnippet

snippet alib "align block" bA
\begin{${1:align*}}
`!p snip.rv = "\n".join(['& ' + line.rstrip().replace("  ", "\\quad ") + '\\\\' for line in snip.v.text.split('\n') if line])`
\end{$1}
endsnippet

snippet alig "align block" bA
`!p snip.rv = "\n".join(['& ' + line.rstrip().replace("  ", "\\quad ") + '\\\\' for line in snip.v.text.split('\n') if line])`
endsnippet

snippet dobint "integral doble" wA
\int\int_${1:D} ${2:f(x,y)}~dA
endsnippet

snippet dood "do..od" wA
\textbf{do} $${1:B} \rightarrow$
  $2
\textbf{od}
endsnippet

snippet loopf "First part of Derivation" bA
## Encontrar Invariante ##
$$I:${1:${VISUAL}}$$
## Inicializacion ##
\{${2:P}\}
S_0
\{$1\}
## Finalizacion ##
$1 \wedge \neg B
\Rightarrow ${3:Q}
endsnippet
snippet loops "Second part of derivation" bA
## Cota candidata ##
## Cuerpo del bucle ##
\{${1:${VISUAL}} \wedge ${2:B}\}
S_1
\{$1\}
## Demostrar que la cota es positiva ##
$1 \wedge $2 \Rightarrow t \Rightarrow 0
## Demostrar que la cota disminuye ##
\{$1 \wedge $2 \wedge t = T\}
S_1
\{t < T\}
endsnippet

snippet !! "index" iA
~!!~
endsnippet

snippet gatb "gather block" bA
\begin{${1:gather*}}
`!p snip.rv = "\n".join([line.rstrip().replace("  ", "\\quad ") + '\\\\' for line in snip.v.text.split('\n') if line])`
\end{$1}
endsnippet

snippet proc "proc template" b
\textbf{proc} ${1:name}(${2:arg})
  $3
\textbf{end proc}
endsnippet

snippet var "var declaration" b
\textbf{var} ${1:name}: ${2:type}
endsnippet

snippet tabb "tabular env" bA
\begin{tabular}{ l l l }
`!p snip.rv = "\n".join(['& ' + line.rstrip().replace("  ", "\\quad ").replace("\t", "\\quad "*4).replace("_", "\\_") + '\\\\' for line in snip.v.text.split('\n') if line])`
\end{tabular}
endsnippet

snippet untab "tabular env" bA
`!p snip.rv = snip.v.text.replace('& ', '').replace('\\quad ', '  ').replace('\\\\', '').replace('\\end{tabular}', '').replace('\\begin{tabular}{ l l l }', '').replace("\\_", "_")`
endsnippet

snippet _ "snake case" w
\_
endsnippet

post_expand "handle_xournalpp(snip)"
snippet xour "xournal++ integration" 
![](`!p if not snip.c: snip.rv = get_new_fig_path(snip)`)
endsnippet

snippet fun "fun template" b
\textbf{fun} ${1:name}(${2:arg}) \textbf{ret} ${3:r} : ${4:type}
  $6
\textbf{end fun}
endsnippet

snippet fort "for to"
\textbf{for} ${1:i} := ${2:N} \textbf{to} ${3:M} \textbf{do}
  $4
\textbf{od}
endsnippet

snippet ford "for downtoto"
\textbf{for} ${1:i} := ${2:N} \textbf{downto} ${3:M} \textbf{do}
  $4
\textbf{od}
endsnippet

snippet arr "array declaration"
array[${1:N}..${2:M}] of ${3:int}
endsnippet

snippet ift "if else"
\textbf{if} ${1:B} \textbf{then}
  ${2:S1}
\textbf{fi}
endsnippet

snippet ifelse "if else"
\textbf{if} ${1:B} \textbf{then}
  ${2:S1}
\textbf{else}
  ${3:skip}
\textbf{fi}
endsnippet

snippet eps "epsilon" i
\epsilon
endsnippet

snippet succ "succession" i
\\{${1:x}_n\\}
endsnippet

snippet while "while do"
\textbf{while} ${1:B} \textbf{do} 
  ${2:S}
\textbf{od}
endsnippet

snippet del "delta" w
\delta
endsnippet

snippet Del "Delta" w
\Delta
endsnippet

snippet "enum(\w+)" "Generalization" wr
`!p snip.rv=match.group(1)` = ${1:0},\ldots, ${2:n}
endsnippet

snippet alp "alpha" w
\alpha
endsnippet

snippet table "make latex table" bA
`!p snip.rv = build_table(snip.v.text)`
endsnippet

snippet undb "underbrace" iA
\underbrace{${1:${VISUAL}}}_{$2}
endsnippet

snippet cI "closed interval" iA
[${1:a}, ${2:b}]
endsnippet

snippet oI "open interval" iA
(${1:a}, ${2:b})
endsnippet

snippet newfig "link to new figure" A
![](`!p if not snip.c: snip.rv = get_new_fig_path(f"./{snip.basename}_imgs/")`){ width=${1:250}px }
endsnippet

snippet spec "specification" b
\textbf{spec} ${1:name} \textbf{of} T \textbf{where}

\textbf{constructors}

\textbf{operations}

\textbf{destroy}
endsnippet
snippet implement "implementation" b
\textbf{implement} ${1:name} \textbf{of} T \textbf{where}
$0
endsnippet

snippet type "implementation" b
\textbf{type} ${1:Typename} = $0
endsnippet

snippet off "Type of" iA
\textbf{of} ${2:T} 
endsnippet

snippet vof "variabel of" iA
${1:name}: ${2:Type} 
endsnippet

snippet points "points to"
${1:pointer} -> ${2:property}
endsnippet

snippet comm "comment"
\\emph{\\{- $1 -\\}}
endsnippet

snippet tuple "tuple"
\textbf{tuple}
  ${1:var}: ${2:Type}
  $3
\textbf{end tuple}
endsnippet

snippet pointer "pointer to"
\textbf{pointer to} ${1:Type}
endsnippet

snippet parg "proc argument" i
\textbf{${2:I/O}} ${3:var}: ${4:type}
endsnippet

snippet proch "proc header" b
\textbf{proc} ${1:name}(${2:arg})
endsnippet

snippet funh "fun header" b
\textbf{fun} ${1:name}(${2:arg}) \textbf{ret} ${3:r} : ${4:type}
endsnippet

snippet code "code" Ab
\`\`\`
  ${VISUAL}$0
\`\`\`
endsnippet

snippet headers "doc headers" Ab
---
title: $1
author: ${2:Lautaro Bachmann}
---
\maketitle
\newpage
\tableofcontents
\newpage

endsnippet

snippet dincomments "partes programacion dinamica" b
\emph{\\{- Declaracion de variables -\\}}
\emph{\\{- Casos base -\\}}
\emph{\\{- Caso recursivo -\\}}
endsnippet

snippet np "new page"
\newpage
$0
endsnippet
## vim:ft=snippets
