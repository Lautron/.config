global !p
import glob, time
def handle_xournalpp(snip):
  directory = f"./{snip.basename}_imgs/"
  os.makedirs(directory, exist_ok=True)
  files = glob.glob(f"{directory}*.png")
  if files: 
    latest = max(files, key=os.path.getctime)
    regx = re.search("fig(\d+)", latest)
    num = int(regx.group(1)) + 1
  else:
    num = 1
  commands = [
    f'xournalpp "{directory}fig{num}.xopp"',
    f'xournalpp --export-no-background -i "{directory}fig{num}.png" "{directory}fig{num}.xopp"',
    f'convert -trim "{directory}fig{num}.png" "{directory}fig{num}.png"'
    ]
  os.system(" && ".join(commands))
  return f"{directory}fig{num}.png"
endglobal
###########################
# Sections and Paragraphs #
###########################
snippet sec "Section" b
# ${1:Section Name}
$0
endsnippet

snippet ssec "Sub Section" b
## ${1:Section Name}
$0
endsnippet

snippet sssec "SubSub Section" b
### ${1:Section Name}
$0
endsnippet

snippet par "Paragraph" b
#### ${1:Paragraph Name}
$0
endsnippet

snippet spar "Paragraph" b
##### ${1:Paragraph Name}
$0
endsnippet

###################
# Text formatting #
###################

#snippet * "italics"
#*${1:${VISUAL}}*$0
#endsnippet
#
#snippet ** "bold"
#**${1:${VISUAL}}**$0
#endsnippet
#
#snippet *** "bold italics"
#***${1:${VISUAL}}***$0
#endsnippet

snippet /* "Comment"
<!-- ${1:${VISUAL}} -->$0
endsnippet

################
# Common stuff #
################
snippet link "Link to something"
[${1:${VISUAL:Text}}](${3:https://${2:www.url.com}})$0
endsnippet

snippet img "Image"
![${1:pic alt}](${2:path}${3/.+/ "/}${3:opt title}${3/.+/"/})$0
endsnippet

snippet ilc "Inline Code" i
\`$1\`$0
endsnippet

snippet cbl "Codeblock" b
\`\`\`
$1
\`\`\`
$0
endsnippet

snippet refl "Reference Link"
[${1:${VISUAL:Text}}][${2:id}]$0

[$2]:${4:https://${3:www.url.com}} "${5:$4}"
endsnippet

snippet fnt "Footnote"
[^${1:${VISUAL:Footnote}}]$0

[^$1]:${2:Text}
endsnippet

snippet detail "Disclosure"
<details${3: open=""}>
  ${1:<summary>${2}</summary>}$0
</details>
endsnippet


###########################
##### LaTeX snippets #####
###########################
#
snippet mk "Math" wA
$$${1}$$`!p
if t[2] and t[2][0] not in [',', '.', '?', '-', ' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`$2
endsnippet

snippet ms "Math" wA
$${1}$`!p
if t[2] and t[2][0] not in [',', '.', '?', '-', ' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`$2
endsnippet

snippet lim "limit" w
\lim_{${1:n} \to ${2:\infty}} 
endsnippet

snippet sqrt "\sqrt{}"
\sqrt{${1:${VISUAL}}} $0
endsnippet

snippet set "set" wA
\\{$1\\} $0
endsnippet

snippet beg "begin{} / end{}" bA
\\begin{$1}
${2:${VISUAL}}
\\end{$1}
endsnippet

priority 100
snippet .. "ldots" wA
\ldots
endsnippet

snippet / "Fraction" i
\\frac{$1}{$2}$0
endsnippet

priority 100
snippet "([^ {]+)/" "symbol frac" wr
\\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet

snippet '([A-Za-z])(\d)' "auto subscript" wr
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`
endsnippet

snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet

snippet sympy "sympy block" w
sympy $1 sympy$0
endsnippet

priority 10000
snippet 'sympy(.*)sympy' "sympy" wr
`!p
from sympy import *
x, y, z, t = symbols('x y z t')
k, m, n = symbols('k m n', integer=True)
f, g, h = symbols('f g h', cls=Function)
init_printing()
snip.rv = eval('latex(' + match.group(1).replace('\\', '').replace('^', '**').replace('{', '(').replace('}', ')') + ')')
`
endsnippet

snippet pmat "pmat" wA
\begin{pmatrix} $1 \end{pmatrix} $0
endsnippet

snippet bmat "bmat" wA
\begin{bmatrix} $1 \end{bmatrix} $0
endsnippet

snippet () "left( right)" wA
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr "left( right)" i
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr( "left( right)" i
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr| "left| right|" i
\left| ${1:${VISUAL}} \right| $0
endsnippet

snippet lr{ "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

snippet lrb "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

snippet lr[ "left[ right]" i
\left[ ${1:${VISUAL}} \right] $0
endsnippet

snippet lra "leftangle rightangle" wA
\left<${1:${VISUAL}} \right>$0
endsnippet

snippet sum "sum" w
\sum_{n=${1:1}}^{${2:\infty}} ${3:a_n}
endsnippet

snippet prod "product" w
\prod_{${1:n=${2:1}}}^{${3:\infty}} ${4:${VISUAL}} $0
endsnippet

snippet part "d/dx" w
\frac{\partial ${1:V}}{\partial ${2:x}} $0
endsnippet

snippet td "to the ... power" i
^{$1}$0
endsnippet

snippet __ "subscript" iA
_{$1}$0
endsnippet

snippet ooo "\infty" wA
\infty
endsnippet

snippet <= "leq" iA
\le 
endsnippet

snippet >= "geq" iA
\ge 
endsnippet

snippet lll "l" iA
\ell
endsnippet

snippet xx "cross" wA
\times 
endsnippet

priority 100
snippet '(?<!\\)(sin|cos|arccot|cot|csc|ln|log|exp|star|perp)' "ln" rw
\\`!p snip.rv = match.group(1)`
endsnippet

priority 200
snippet '(?<!\\)(arcsin|arccos|arctan|arccot|arccsc|arcsec|zeta|int)' "ln" rw
\\`!p snip.rv = match.group(1)`
endsnippet

priority 100
snippet "([a-zA-Z])bar" "bar" rw
\bar{`!p snip.rv=match.group(1)`}
endsnippet

snippet inn "in " wA
\in 
endsnippet

snippet cc "subset" wA
\subset 
endsnippet

priority 90
snippet -> "to" wA
\to 
endsnippet

snippet norm "norm" w
\|$1\|$0
endsnippet

###########################
##### Custom snippets #####
###########################

snippet eqq "equivalent" wA
\equiv 
endsnippet

snippet "(\w+)!(\d+)" "index" wrA
`!p snip.rv=match.group(1)`~!~`!p snip.rv=match.group(2)`
endsnippet

snippet /= "not equal" wA
\neq
endsnippet

snippet range "range" wA
${2:0} \leq $1 < ${3:\#xs} $4
endsnippet

snippet # "cardinal" w
\#
endsnippet

snippet brang "bracket angled" wA
\langle $1 \rangle
endsnippet

snippet AA "forall" wA
\forall
endsnippet

snippet EE "exists" wA
\exists
endsnippet

priority 100
snippet --> "arrow" wA
\rightarrow 
endsnippet

snippet andd "and" wA
\wedge 
endsnippet

snippet orr "or" wA
\vee 
endsnippet

snippet props "props" iA
\equiv \\{ \text{$1} \\}
$0
endsnippet

snippet negg "negation" wA
\neg 
endsnippet

snippet undd "underline" wA
\underline{${1:${VISUAL}}}
endsnippet

snippet mbf "bold math" wA
\mathbf{${1:${VISUAL}}}
endsnippet

snippet bf "bold text" wA
\textbf{${1:${VISUAL}}}
endsnippet

snippet squigg "squiggly arrow" wA
\rightsquigarrow 
endsnippet

snippet o+ "oplus" wA
\oplus
endsnippet

snippet pegg "pegado" wA
\triangleright
endsnippet

snippet Sig "Uppercase Sigma" wA
\Sigma
endsnippet

snippet PI "Uppercase Pi" wA
\Pi
endsnippet

priority 50
snippet RR "real" wA
\mathbb{R}
endsnippet

snippet NN "natural" wA
\mathbb{N}
endsnippet

snippet II "I" wA
\mathbb{I}
endsnippet

snippet KK "K" wA
\mathbb{K}
endsnippet

snippet uiN "undefined integral" wA
\int $1~dx $0
endsnippet

snippet diN "integral" wA
\int_{${1:-\infty}}^{${2:\infty}}$3~${4:dx} $0
endsnippet

snippet uP "up arrow" wA
\uparrow
endsnippet

snippet ++ "concatenation operator" wA
\concat 
endsnippet

snippet concatDef "concat command definition" b
\newcommand{\concat}{%
  \mathbin{{+}\mspace{-8mu}{+}}%
}
endsnippet

snippet => "Right arrow" wA
\Rightarrow 
endsnippet

snippet taylor "taylor" wA
\frac{f^{(${1:n})}(${2:a})}{${3:n}!} $0
endsnippet

snippet funcder "Function Derivation" wA
${1:f}^{(${2:n})}(${3:a}) $0 
endsnippet
#snippet vD "Variable declaration" iA
#$Var~ $1: ${2:Int};$\
#$0
#endsnippet

snippet stn "state name" wA
$\sigma_{$1}$
endsnippet

snippet lnn "line name" wA
$\ell_{$1}$
endsnippet

priority 100
snippet "(\w+)mt" "maps to" rwA
`!p snip.rv=match.group(1)` \mapsto $1
endsnippet

snippet conm "conjunto matriz" wA
${1:\mathbb{K}}^{${2:n}\times ${3:n}} $0
endsnippet

snippet iff "Leftrightarrow" wA
\Leftrightarrow 
endsnippet

snippet rH "Row header" bA
|    linea   | nombre del estado |       estado/guardas      |   aclaracion   |
|:----------:|:-----------------:|:-------------------------:|:--------------:|
|     -      |    $\sigma_{0}$   | $$1$                      | Estado inicial |
endsnippet

snippet terh "Inline Terna de Hoare" wA
\\{${1:P}\\}~${3:S}~\\{${2:Q}\\} $0
endsnippet

snippet terH "Terna de Hoare" wA
\\{${1:P}\\}
$3
\\{${2:Q}\\}
$0
endsnippet

snippet "gen(\w+)" "Generalization" wr
${1:`!p snip.rv=match.group(1)`}_1,\ldots,$1_${2:n}
endsnippet

snippet mc "mathcal" w
\mathcal{$1} $0
endsnippet

snippet "dom([a-zA-Z])" "Dominio" rwA
Dom(`!p snip.rv=match.group(1)`) $0
endsnippet

priority 100
snippet "(\w)RR" "R^n" rwA
\mathbb{R}^`!p snip.rv=match.group(1)` $0
endsnippet

snippet fndef "function definition" wA
${1:f}:${2:\mathbb{R}^n}\to ${3:\mathbb{R}}
endsnippet

snippet "txt([a-zA-Z]+)" "text" r
\text{ `!p snip.rv=match.group(1)`$2 } $1
endsnippet

priority 50
snippet "([^ {]+)sqrt" "square root" rwA
\sqrt{`!p snip.rv=match.group(1)`} $0
endsnippet

snippet c= "subset" Ai
\subseteq 
endsnippet

snippet "([^ ]+)<-([^ ])" "left arrow" rA
`!p snip.rv=match.group(1)` \leftarrow `!p snip.rv=match.group(2)`
endsnippet

snippet wp "weakest precondition" w
wp.($1).($2)
endsnippet

snippet wpif "wp(if...fi)" bA
(${1:B1} \vee ${2:B2})
\wedge ($1 \Rightarrow wp.(${4:S0}).${3:${VISUAL}})
\wedge ($2 \Rightarrow wp.(${5:S1}).$3)
endsnippet

snippet if "if..fi" w
if~${1:expression}\rightarrow $2
$3
fi
endsnippet

snippet else "[] ->" w
[]~${1:expression}\rightarrow $2
$3
endsnippet

snippet grad "gradient" w
\nabla ${3:f}(${1:\bar{a}})$2
endsnippet

snippet fndom "function definition based on Dom(f)" wA
${1:f}:${2:Dom(f) \subseteq \mathbb{R}^n}\to ${3:\mathbb{R}}
endsnippet

snippet bola "bola" w
B(${1:\bar{a}}, ${2:r})
endsnippet

snippet dim "Dimension" wA
dim~
endsnippet

snippet verdo "verification do" wA
P \Rightarrow ${4:I} 
\wedge $4 \wedge \neg (${1:B}) \Rightarrow ${3:Q}
\wedge \\{$4 \wedge $1\\} ${2:S} \\{$4\\} 
\wedge $4 \wedge $1 \Rightarrow t \ge 0
\wedge \\{$4 \wedge $1 \wedge t = T\\} $2 \\{t < T\\} 
endsnippet

snippet alib "align block" bA
\begin{${1:align*}}
`!p snip.rv = "\n".join(['& ' + line.rstrip().replace("  ", "\\quad ") + '\\\\' for line in snip.v.text.split('\n') if line])`
\end{$1}
endsnippet

snippet alig "align block" bA
`!p snip.rv = "\n".join(['& ' + line.rstrip().replace("  ", "\\quad ") + '\\\\' for line in snip.v.text.split('\n') if line])`
endsnippet

snippet dobint "integral doble" wA
\int\int_${1:D} ${2:f(x,y)}~dA
endsnippet

snippet dood "do..od" wA
\textbf{do} $${1:B} \rightarrow$
  $2
\textbf{od}
endsnippet

snippet loopf "First part of Derivation" bA
## Encontrar Invariante ##
$$I:${1:${VISUAL}}$$
## Inicializacion ##
\{${2:P}\}
S_0
\{$1\}
## Finalizacion ##
$1 \wedge \neg B
\Rightarrow ${3:Q}
endsnippet
snippet loops "Second part of derivation" bA
## Cota candidata ##
## Cuerpo del bucle ##
\{${1:${VISUAL}} \wedge ${2:B}\}
S_1
\{$1\}
## Demostrar que la cota es positiva ##
$1 \wedge $2 \Rightarrow t \Rightarrow 0
## Demostrar que la cota disminuye ##
\{$1 \wedge $2 \wedge t = T\}
S_1
\{t < T\}
endsnippet

snippet !! "index" iA
~!!~
endsnippet

snippet gatb "gather block" bA
\begin{${1:gather*}}
`!p snip.rv = "\n".join([line.rstrip().replace("  ", "\\quad ") + '\\\\' for line in snip.v.text.split('\n') if line])`
\end{$1}
endsnippet

snippet proc "proc template" b
\textbf{proc} ${1:name}(\textbf{${2:I/O}} ${3:var}: ${4:type})
  $5
\textbf{end proc}
endsnippet

snippet var "var declaration" b
\textbf{var} ${1:name}: \textbf{${2:type}}
endsnippet

snippet tabb "tabular env" bA
\begin{tabular}{ l l l }
`!p snip.rv = "\n".join(['& ' + line.rstrip().replace("  ", "\\quad ") + '\\\\' for line in snip.v.text.split('\n') if line])`
\end{tabular}
endsnippet

snippet _ "snake case" w
\_
endsnippet

snippet xour "xournal++ integration" 
![](`!p if not snip.c: snip.rv = handle_xournalpp(snip)`){ width=${1:250}px }
endsnippet

snippet fun "fun template" b
\textbf{fun} ${1:name}(${2:var}: ${3:type} \textbf{ret} ${4:r} : ${5:type}
  $6
\textbf{end fun}
endsnippet

snippet fort "for to"
\textbf{for} ${1:i} := ${2:N} \textbf{to} ${3:M} \textbf{do}
  $4
\textbf{od}
endsnippet

snippet ford "for downtoto"
\textbf{for} ${1:i} := ${2:N} \textbf{downto} ${3:M} \textbf{do}
  $4
\textbf{od}
endsnippet

snippet arr "array declaration"
array[${1:N}..${2:M}] of ${3:int}
endsnippet

snippet ifel "if else"
\textbf{if} ${1:B} \textbf{then}
  ${2:S1}
\textbf{else}
  ${3:skip}
\textbf{fi}
endsnippet

#snippet xour "xournal++ integration" 
#![](`!p if not snip.c:
#  file = os.popen(f"~/.config/nvim/user_snippets/xournalpp.sh {snip.basename}_imgs")
#  snip.rv = file.read()[2:].strip()`){ width=${1:250}px }
#endsnippet
## Interesting snippet example ##
#------------------- SNIP -------------------
#snippet r "return" "re.match('^\s+if err ', snip.buffer[snip.line-1])" be
#return err
#endsnippet
#------------------- SNAP -------------------
#
#That snippet will expand to 'return err' only if the previous line is starting
#from 'if err' prefix.
## vim:ft=snippets
