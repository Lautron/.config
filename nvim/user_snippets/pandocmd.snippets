#global !p
#def math():
#	return vim.eval('vimtex#syntax#in_mathzone()') == '1'
#
#def comment(): 
#	return vim.eval('vimtex#syntax#in_comment()') == '1'
#
#def env(name):
#	[x,y] = vim.eval("vimtex#env#is_inside('" + name + "')") 
#	return x != '0' and y != '0'
#
###########################
# Sections and Paragraphs #
###########################
snippet sec "Section" b
# ${1:Section Name} #
$0
endsnippet

snippet ssec "Sub Section" b
## ${1:Section Name} ##
$0
endsnippet

snippet sssec "SubSub Section" b
### ${1:Section Name} ###
$0
endsnippet

snippet par "Paragraph" b
#### ${1:Paragraph Name} ####
$0
endsnippet

snippet spar "Paragraph" b
##### ${1:Paragraph Name} #####
$0
endsnippet

###################
# Text formatting #
###################

#snippet * "italics"
#*${1:${VISUAL}}*$0
#endsnippet
#
#snippet ** "bold"
#**${1:${VISUAL}}**$0
#endsnippet
#
#snippet *** "bold italics"
#***${1:${VISUAL}}***$0
#endsnippet

snippet /* "Comment"
<!-- ${1:${VISUAL}} -->$0
endsnippet

################
# Common stuff #
################
snippet link "Link to something"
[${1:${VISUAL:Text}}](${3:https://${2:www.url.com}})$0
endsnippet

snippet img "Image"
![${1:pic alt}](${2:path}${3/.+/ "/}${3:opt title}${3/.+/"/})$0
endsnippet

snippet ilc "Inline Code" i
\`$1\`$0
endsnippet

snippet cbl "Codeblock" b
\`\`\`
$1
\`\`\`
$0
endsnippet

snippet refl "Reference Link"
[${1:${VISUAL:Text}}][${2:id}]$0

[$2]:${4:https://${3:www.url.com}} "${5:$4}"
endsnippet

snippet fnt "Footnote"
[^${1:${VISUAL:Footnote}}]$0

[^$1]:${2:Text}
endsnippet

snippet detail "Disclosure"
<details${3: open=""}>
  ${1:<summary>${2}</summary>}$0
</details>
endsnippet


###########################
##### LaTeX snippets #####
###########################
#
snippet mk "Math" wA
$$${1}$$`!p
if t[2] and t[2][0] not in [',', '.', '?', '-', ' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`$2
endsnippet

snippet ms "Math" wA
$${1}$`!p
if t[2] and t[2][0] not in [',', '.', '?', '-', ' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`$2
endsnippet

snippet lim "limit" w
\lim_{${1:n} \to ${2:\infty}} 
endsnippet

snippet sqrt "\sqrt{}"
\sqrt{${1:${VISUAL}}} $0
endsnippet

snippet set "set" wA
\\{$1\\} $0
endsnippet

snippet beg "begin{} / end{}" bA
\\begin{$1}
	$0
\\end{$1}
endsnippet

priority 100
snippet ... "ldots" wA
\ldots
endsnippet

snippet table "Table environment" b
\begin{table}[${1:htpb}]
	\centering
	\caption{${2:caption}}
	\label{tab:${3:label}}
	\begin{tabular}{${5:c}}
	$0${5/((?<=.)c|l|r)|./(?1: & )/g}
	\end{tabular}
\end{table}
endsnippet

snippet / "Fraction" i
\\frac{$1}{$2}$0
endsnippet

priority 100
snippet '((\d+)|(\d*)(\\)?([A-Za-z]+)((\^|_)(\{\d+\}|\d))*)/' "symbol frac" wrA
\\frac{`!p snip.rv = match.group(2)`}{$1}$0
endsnippet

snippet '([A-Za-z])(\d)' "auto subscript" wrA
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`
endsnippet

snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet

snippet sympy "sympy block" w
sympy $1 sympy$0
endsnippet

priority 10000
snippet 'sympy(.*)sympy' "sympy" wr
`!p
from sympy import *
x, y, z, t = symbols('x y z t')
k, m, n = symbols('k m n', integer=True)
f, g, h = symbols('f g h', cls=Function)
init_printing()
snip.rv = eval('latex(' + match.group(1).replace('\\', '').replace('^', '**').replace('{', '(').replace('}', ')') + ')')
`
endsnippet

snippet pmat "pmat" wA
\begin{pmatrix} $1 \end{pmatrix} $0
endsnippet

snippet bmat "bmat" wA
\begin{bmatrix} $1 \end{bmatrix} $0
endsnippet

snippet () "left( right)" wA
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr "left( right)" i
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr( "left( right)" i
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr| "left| right|" i
\left| ${1:${VISUAL}} \right| $0
endsnippet

snippet lr{ "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

snippet lrb "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

snippet lr[ "left[ right]" i
\left[ ${1:${VISUAL}} \right] $0
endsnippet

snippet lra "leftangle rightangle" wA
\left<${1:${VISUAL}} \right>$0
endsnippet

snippet sum "sum" w
\sum_{n=${1:1}}^{${2:\infty}} ${3:a_n}
endsnippet

snippet prod "product" w
\prod_{${1:n=${2:1}}}^{${3:\infty}} ${4:${VISUAL}} $0
endsnippet

snippet part "d/dx" w
\frac{\partial ${1:V}}{\partial ${2:x}} $0
endsnippet

snippet td "to the ... power" wA
^{$1}$0
endsnippet

snippet __ "subscript" iA
_{$1}$0
endsnippet

snippet ooo "\infty" wA
\infty
endsnippet

snippet <= "leq" wA
\le 
endsnippet

snippet >= "geq" wA
\ge 
endsnippet

snippet lll "l" wA
\ell
endsnippet
snippet xx "cross" wA
\times 
endsnippet


priority 100
snippet '(?<!\\)(sin|cos|arccot|cot|csc|ln|log|exp|star|perp)' "ln" rwA
\\`!p snip.rv = match.group(1)`
endsnippet

priority 200
snippet '(?<!\\)(arcsin|arccos|arctan|arccot|arccsc|arcsec|pi|zeta|int)' "ln" rwA
\\`!p snip.rv = match.group(1)`
endsnippet

priority 100
snippet "([a-zA-Z])bar" "bar" rwA
\bar{`!p snip.rv=match.group(1)`}
endsnippet

snippet inn "in " wA
\in 
endsnippet

snippet cc "subset" Ai
\subset 
endsnippet

snippet c= "subset" Ai
\subseteq 
endsnippet

priority 90
snippet -> "to" wA
\to 
endsnippet

snippet norm "norm" w
\|$1\|$0
endsnippet

###########################
##### Custom snippets #####
###########################

snippet eQ "equivalent" iA
\equiv 
endsnippet

snippet inD "index" iA
~!!~
endsnippet

snippet neQ "not equal" iA
\neq
endsnippet

snippet ranG "range" iA
${2:0} \leq $1 < ${3:\#xs} $4
endsnippet

snippet cardi "cardinal" iA
\#
endsnippet

snippet brang "bracket angled" iA
\langle $1 \rangle
endsnippet

snippet fA "forall" iA
\forall
endsnippet

snippet EE "exists" iA
\exists
endsnippet

priority 100
snippet --> "arrow" iA
\rightarrow 
endsnippet

snippet inlist "in list" iA
\in_l
endsnippet

snippet anD "and" iA
\wedge 
endsnippet

snippet oR "or" iA
\vee 
endsnippet

snippet props "props" iA
$$\equiv \\{ \text{$0} \\}$$
endsnippet

snippet negg "negation" iA
\neg 
endsnippet

snippet undd "underline" iA
\underline{$1}
endsnippet

snippet bf "bold math" iA
\mathbf{$1}
endsnippet

snippet != "nequals" iA
\neq 
endsnippet

snippet squiG "squiggly arrow" iA
\rightsquigarrow 
endsnippet

snippet oP "oplus" iA
\oplus
endsnippet

snippet imP "implies" iA
\implies
endsnippet

snippet peG "pegado" iA
\triangleright
endsnippet

snippet SiG "Uppercase Sigma" iA
\Sigma
endsnippet

snippet PI "Uppercase Pi" iA
\Pi
endsnippet

priority 50
snippet RR "real" iA
\mathbb{R}
endsnippet

snippet NN "natural" iA
\mathbb{N}
endsnippet

snippet II "I" iA
\mathbb{I}
endsnippet

snippet KK "K" iA
\mathbb{K}
endsnippet

snippet uiN "undefined integral" iA
\int $1~dx $0
endsnippet

snippet diN "integral" wA
\int_{${1:-\infty}}^{${2:\infty}}$3~${4:dx} $0
endsnippet

snippet uP "up arrow" iA
\uparrow
endsnippet

snippet ++ "concatenation operator" iA
\concat 
endsnippet

snippet concatDef "concat command definition" iA
\newcommand{\concat}{%
  \mathbin{{+}\mspace{-8mu}{+}}%
}
endsnippet

snippet rA "Right arrow" iA
\Rightarrow  
endsnippet

snippet taY "taylor" wA
\frac{f^{(${1:n})}(${2:a})}{${3:n}!} $0
endsnippet

snippet fD "Function Derivation" iA
${1:f}^{(${2:n})}(${3:a}) $0 
endsnippet

#snippet sT "State" iA
#$\Brackets{\sigma_$1: $2 \mapsto $3}$\
#$0
#endsnippet
#
snippet pL "Program Line" iA
$\ell_{$1}\quad $2$\
$0
endsnippet

#snippet vD "Variable declaration" iA
#$Var~ $1: ${2:Int};$\
#$0
#endsnippet

snippet sT "state name" iA
$\sigma_{$1}$
endsnippet

snippet lN "line name" iA
$\ell_{$1}$
endsnippet

snippet mT "maps to" iA
\mapsto $0
endsnippet

snippet sQ "square" iA
\square~$0
endsnippet

snippet qU "quad" iA
 \quad $0
endsnippet

snippet ptR "program trace row" iA
| $$1$ | $$2$ | $$3$ | $4 |
$0
endsnippet

snippet conM "quad" iA
${1:\mathbb{K}}^{${2:n}\times ${3:n}} $0
endsnippet

snippet lrA "Leftrightarrow" iA
\Leftrightarrow 
endsnippet

snippet rH "Row header" iA
|    linea   | nombre del estado |       estado/guardas      |   aclaracion   |
|:----------:|:-----------------:|:-------------------------:|:--------------:|
|     -      |    $\sigma_{0}$   | $$1$                      | Estado inicial |
endsnippet

snippet tH "Terna de Hoare" iA
\\{${1:P}\\}~${3:S}~\\{${2:Q}\\} $0
endsnippet

snippet TH "Terna de Hoare" iA
$$\\{${1:P}\\}$$
$$$3$$
$$\\{${2:Q}\\}$$
$0
endsnippet

snippet geN "Generalization" iA
$1_1,\ldots,$1_n$0
endsnippet

snippet mc "mathcal" wA
\mathcal{$1} $0
endsnippet

snippet "dom([a-zA-Z])" "Dominio" riA
Dom(`!p snip.rv=match.group(1)`) $0
endsnippet

priority 100
snippet "(\w)RR" "R^n" riA
\mathbb{R}^`!p snip.rv=match.group(1)` $0
endsnippet

snippet funcdef "function definition" iA
${1:f}:${2:\mathbb{R}^n}\to
endsnippet

snippet subset "subset" iA
\subset
endsnippet

snippet in "in" wA
\in
endsnippet

snippet "txt([a-zA-Z]+)" "text" r
\text{ `!p snip.rv=match.group(1)`$2 } $1
endsnippet

snippet test "test"
capo{${VISUAL}}
endsnippet

## Interesting snippet example ##
#------------------- SNIP -------------------
#snippet r "return" "re.match('^\s+if err ', snip.buffer[snip.line-1])" be
#return err
#endsnippet
#------------------- SNAP -------------------
#
#That snippet will expand to 'return err' only if the previous line is starting
#from 'if err' prefix.
## vim:ft=snippets
