priority -50

extends c

# We want to overwrite everything in parent ft.
priority -49
###########################################################################
#			    Global functions 						  #
###########################################################################

global !p

def write_docstring_args(arglist, snip):
	args = str(arglist).split(',')

	if len(args) > 1:
		c = 0
		for arg in args:
			if c == 0:
				snip.rv += arg
				c = 1
			else:
				snip += '*       : %s' % arg.strip()
	else:
		snip.rv = args[0]


endglobal

###########################################################################
#                            TextMate Snippets                            #
###########################################################################
snippet main
int main()
{
	${0}
}
endsnippet

snippet forc "general for loop (for)"
for (${6:auto} ${1:i} = ${2:v.begin()}; `!p import re; snip.rv = re.split("[^\w]",t[1])[-1]` ${4:!=} ${3:`!p m = re.search(r'^(?:(.*)(\.|->)begin\(\)|((?:std|boost)::)?begin\((.*)\))$', t[2]); snip.rv = (((m.group(3) if m.group(3) else "") + "end(" + m.group(4) + ")") if m.group(4) else (m.group(1) + m.group(2) + "end()")) if m else ""`}; ${5:++`!p snip.rv = t[1].split(" ")[-1]`}) {
	${VISUAL}$0
}
endsnippet

snippet beginend "$1.begin(), $1.end() (beginend)"
${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
endsnippet

snippet cl "class .. (class)"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
	${1/(\w+).*/$1/} (${2:arguments});
	virtual ~${1/(\w+).*/$1/} ();

private:
	${0:/* data */}
};
endsnippet

snippet ns "namespace .. (namespace)"
namespace${1/.+/ /m}${1:`!p snip.rv = snip.basename or "name"`}
{
	${VISUAL}$0
}${1/.+/ \/* /m}$1${1/.+/ *\/ /m}
endsnippet

snippet readfile "read file (readF)"
vector<char> v;
if (FILE *fp = fopen(${1:"filename"}, "r"))
{
	char buf[1024];
	while(size_t len = fread(buf, 1, sizeof(buf), fp))
		v.insert(v.end(), buf, buf + len);
	fclose(fp);
}
endsnippet

snippet map "map (map)"
map<${1:key}, ${2:value}> map$0;
endsnippet

snippet vector "vector (v)"
vector<${1:char}> v$0;
endsnippet

snippet tp "template <typename ..> (template)"
template <typename ${1:_InputIter}>
endsnippet

snippet cla "An entire .h generator" b
#ifndef ${2:`!v substitute(vim_snippets#Filename('$1_H','ClassName'),'.*','\U&\E','')`}
#define $2

class ${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}
{
private:
	$3

public:
	$1();
	virtual ~$1();
};

#endif /* $2 */
endsnippet


snippet fnc "Basic c++ doxygen function template" b
/**
* @brief: ${4:brief}
*
* @param: `!p write_docstring_args(t[3],snip)`
*
* @return: `!p snip.rv = t[1]`
*/
${1:ReturnType} ${2:FunctionName}(${3:param})
{
	${0:FunctionBody}
}
endsnippet

snippet boost_test "Boost test module" b
#define BOOST_TEST_MODULE ${1:TestModuleName}
#include <boost/test/included/unit_test.hpp>

BOOST_AUTO_TEST_CASE(${2:TestCaseName})
{
	${0:TestDefinition}
}

endsnippet

snippet boost_suite "Boost test suite module" b
#define BOOST_TEST_MODULE ${1:TestModuleName}
#include <boost/test/included/unit_test.hpp>

BOOST_AUTO_TEST_SUITE(${2:SuiteName})

BOOST_AUTO_TEST_CASE(${3:TestCaseName})
{
	${0:TestDefinition}
}

BOOST_AUTO_TEST_SUITE_END()

endsnippet
snippet boost_test_fixture "Boost test module with fixture" b
#define BOOST_TEST_MODULE ${1:TestModuleName}
#include <boost/test/included/unit_test.hpp>

struct ${2:FixtureName} {
	$2() {}
	virtual ~$2() {}
	/* define members here */
};

BOOST_FIXTURE_TEST_CASE(${3:SuiteName}, $2)
{
	${0:TestDefinition}
}

endsnippet

snippet boost_suite_fixture "Boost test suite with fixture" b
#define BOOST_TEST_MODULE ${1:TestModuleName}
#include <boost/test/included/unit_test.hpp>

struct ${2:FixtureName} {
	$2() {}
	virtual ~$2() {}
	/* define members here */
};

BOOST_FIXTURE_TEST_SUITE(${3:SuiteName}, $2)

BOOST_AUTO_TEST_CASE(${4:TestCaseName})
{
	${0:TestDefinition}
}

BOOST_AUTO_TEST_SUITE_END()

endsnippet
# vim:ft=snippets:
###########################
# Competitive programming #
###########################
snippet comp "Compettive programming template"
#include <bits/stdc++.h>
using namespace std;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define sortD(v) sort(v.begin(), v.end(), greater<auto>())
#define sortall(x) sort(all(x))

#define fore(it, s) for (vit it = s.begin(); it != s.end(); ++it)
#define fori (i, n) for (int i = 0; i < (n); ++i)
#define fst first
#define snd second
#define pb push_back

typedef long long ll;
typedef pair<int, int> ii;
typedef vector<int> vi;
typedef vector<ii> vii;
typedef vector<long long int> vll;
typedef vector<char> vc;

typedef set<int>::iterator sit;
typedef map<int, int>::iterator mit;
typedef vector<int>::iterator vit;
typedef vector<ll>::iterator vllit;

const int INF = 1e9 + 7;
const int MOD = 1e9 + 7;
const int MAXN = 1e6 + 3;

void solve()
{
  $0;
}

int main()
{
  ios::sync_with_stdio(false);
  solve();
}
endsnippet

snippet rvec "read vector"
${1:vll} read_input_vector(ll size){
  $1 v;
  for (int i = 0; i < size; ++i){
    ll aux;
    cin >> aux;
    v.push_back(aux)
  }
  return v;
}
endsnippet

snippet ovec "output vector"
void out_vector(${1:vll} v){
  for (int i = 0; i < v.size(); ++i)
    cout << v[i] << " ";
}
$0
endsnippet

snippet bpow "binary power"
ll binary_power(ll a, ll b){
  ll res = 1;
  while (b > 0){
    if (b & 1)
      res = res * a;
    a = a * a;
    b >>= 1;
  }
  return res;
}
endsnippet

snippet bpowm "binary power mod"
ll binary_power_mod(ll a, ll b, ll m){
  a %= m;
  ll res = 1;
  while (b > 0){
    if (b & 1)
      res = res * a % m;
    a = a * a % m;
    b >>= 1;
  }
  return res;
}
endsnippet

snippet omap "output map"
void out_map(map<ll,ll> m){
  for (auto it = m.begin(); it != m.end(); it++)
    cout << it->first << " ";
}
endsnippet

snippet stfunct	"state functor"
struct $1 {
 $1($2 val)
  : x(val)
 {
 }
 int operator()(int y) {
  $0;
 }
 private:
 ${2:int} x;
};
endsnippet

snippet funct "simple functor"
struct $1
{
 ${2:int} operator()($2 x) { return $0;}
};
endsnippet

## Iteration
# for i
snippet fori
for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
 ${4}
}
endsnippet

# foreach
snippet fore
for (${1:auto} ${2:i} : ${3:container}) {
 ${4}
}
endsnippet
# iterator
snippet iter
for (${1:vit} ${2:i} = ${3:container}.begin(); $2 != $3.end(); ++$2) {
 ${4}
}
endsnippet

# auto iterator
snippet itera
for (auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
 ${3:cout << *$1 << endl;}
}
endsnippet
## Lambdas
# lamda (one line)
snippet ld
[${1}](${2}){${3}};
endsnippet

# lambda (multi-line)
snippet lld
[${1}](${2}){
 ${3}
};
endsnippet

snippet cout
cout << $1;
$0
endsnippet

snippet coutn
cout << $1 << "\n";
$0
endsnippet

snippet cin
cin >> $1;
$0
endsnippet

snippet adjlist
void add_edge(vector<int> adj[], int u, int v)
{
  assert(u > 0 && v > 0);
  adj[u - 1].push_back(v);
  adj[v - 1].push_back(u);
}

void display_adjlist(vector<int> adj[], int V)
{
  for (int v = 0; v < V; ++v) {
    cout << "\n Adjacency list of vertex "
	 << v + 1 << "\n head ";
    for (auto x : adj[v])
      cout << "-> " << x;
  }
}
endsnippet

snippet initadjl
vi adj[${1:vertices}];
endsnippet

snippet initadjm
vector<vi> adj_matrix(${1:numVertices}, vi($1, 0));
endsnippet

snippet adjmatrix
void displayMatrix(vector<vi> vertArr, ll v)
{
  int i, j;
  for (i = 0; i < v; i++) {
    for (j = 0; j < v; j++) {
      cout << vertArr[i][j] << " ";
    }
    cout << endl;
  }
}
void add_undirected(vector<vi>& vertArr, int u, int v)
{ //function to add edge into the matrix
  assert(u > 0 && v > 0);
  vertArr[u - 1][v - 1] = 1;
  vertArr[v - 1][u - 1] = 1;
}

void add_directed(vector<vi>& vertArr, int u, int v)
{ //function to add edge into the matrix
  assert(u > 0 && v > 0);
  vertArr[u - 1][v - 1] = 1;
}
void add_weighted(vector<vi>& vertArr, int u, int v, int w)
{ //function to add edge into the matrix
  assert(u > 0 && v > 0);
  vertArr[u - 1][v - 1] = w;
}
endsnippet


